#!/usr/bin/env node
/**
 * Sync stage snapshot data into docs/wiki/ for VitePress deployment.
 *
 * Reads all versioned stage directories (docs/stage/v*) and regenerates:
 *   - docs/wiki/reference/changelog.md
 *   - docs/wiki/reference/architecture.md
 *
 * Usage: node update-wiki-from-stage.mjs [--version <version>]
 *        Without --version, uses the latest stage.
 */

import { readFile, writeFile, readdir, stat } from "node:fs/promises";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, "..", "..");
const STAGE_DIR = join(ROOT, "docs", "stage");
const WIKI_DIR = join(ROOT, "docs", "wiki");

async function getVersionDirs() {
  const entries = await readdir(STAGE_DIR).catch(() => []);
  const versions = [];
  for (const name of entries) {
    if (!name.startsWith("v")) continue;
    const s = await stat(join(STAGE_DIR, name)).catch(() => null);
    if (s?.isDirectory()) versions.push(name);
  }
  return versions.sort((a, b) => {
    const pa = a.replace("v", "").split(".").map(Number);
    const pb = b.replace("v", "").split(".").map(Number);
    for (let i = 0; i < 3; i++) {
      if ((pa[i] || 0) !== (pb[i] || 0)) return (pa[i] || 0) - (pb[i] || 0);
    }
    return 0;
  });
}

async function readStageFile(version, filename) {
  try {
    return await readFile(join(STAGE_DIR, version, filename), "utf8");
  } catch {
    return null;
  }
}

async function readMetadata(version) {
  const raw = await readStageFile(version, "metadata.json");
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch {
    return null;
  }
}

function extractChangelogSummary(changelogMd) {
  if (!changelogMd) return null;
  const lines = changelogMd.split("\n");
  const summary = [];
  let started = false;
  for (const line of lines) {
    if (line.startsWith("## ") && !line.includes("Changelog")) {
      started = true;
    }
    if (started && line.startsWith("---")) break;
    if (started) summary.push(line);
  }
  return summary.length > 0 ? summary.join("\n").trim() : null;
}

async function generateChangelog(versions) {
  const latest = versions[versions.length - 1];
  const sections = [];

  for (const ver of [...versions].reverse()) {
    const meta = await readMetadata(ver);
    const changelog = await readStageFile(ver, "changelog.md");
    const date = meta?.date?.slice(0, 10) || "";
    const badge = ver === latest ? ' <Badge type="tip" text="当前" />' : "";

    let body = "";
    if (changelog) {
      const summary = extractChangelogSummary(changelog);
      if (summary) {
        body = "\n" + summary;
      }
    }

    if (!body) {
      const diffFile = await readStageFile(ver, `diff-from-${versions[versions.indexOf(ver) - 1] || ""}.md`);
      if (diffFile) {
        body = "\n" + diffFile.split("\n").slice(0, 30).join("\n");
      }
    }

    sections.push(`## ${ver}${badge}\n\n> ${date}\n${body || "\n_详见仓库 docs/stage/" + ver + "/changelog.md_"}`);
  }

  const content = `---
generated: true
---

<!-- GENERATED BY update-wiki-from-stage.mjs — DO NOT EDIT MANUALLY -->

# Changelog

${sections.join("\n\n")}

---

完整变更日志见仓库中 \`docs/stage/v<version>/changelog.md\`。
`;
  return content;
}

async function generateArchitecture(versions) {
  const latest = versions[versions.length - 1];
  const archMd = await readStageFile(latest, "architecture.md");
  const meta = await readMetadata(latest);

  if (archMd) {
    const content = `---
generated: true
---

<!-- GENERATED BY update-wiki-from-stage.mjs — DO NOT EDIT MANUALLY -->

# 架构概览

> 基于 ${latest} (${meta?.date?.slice(0, 10) || "latest"})

${archMd.replace(/^#\s+.+\n/, "").trim()}

---

详细版本快照见仓库中 \`docs/stage/${latest}/architecture.md\`。
`;
    return content;
  }

  return null;
}

async function main() {
  const versions = await getVersionDirs();
  if (versions.length === 0) {
    console.error("No staged versions found in docs/stage/");
    process.exit(1);
  }

  const latest = versions[versions.length - 1];
  console.log(`Found ${versions.length} staged versions, latest: ${latest}`);

  const changelogContent = await generateChangelog(versions);
  const changelogPath = join(WIKI_DIR, "reference", "changelog.md");
  await writeFile(changelogPath, changelogContent, "utf8");
  console.log(`✓ Updated ${changelogPath.replace(ROOT + "/", "").replace(ROOT + "\\", "")}`);

  const archContent = await generateArchitecture(versions);
  if (archContent) {
    const archPath = join(WIKI_DIR, "reference", "architecture.md");
    await writeFile(archPath, archContent, "utf8");
    console.log(`✓ Updated ${archPath.replace(ROOT + "/", "").replace(ROOT + "\\", "")}`);
  } else {
    console.log("⚠ No architecture.md found in latest stage, skipping");
  }

  console.log("\nWiki reference pages updated. Commit and push to trigger deployment.");
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
