{
  "id": 35,
  "title": "ACP 完整协议层 — Core ACP Gateway + Proxy/Chat 接入",
  "status": "open",
  "labels": [
    "acp",
    "feature",
    "protocol",
    "priority:P1"
  ],
  "milestone": "mid-term",
  "body": "## 目标\n\n将 AgentCraft Core (Daemon) 升级为 **ACP-to-ACP Gateway**，实现 ACP 端到端通信，支持多种 Client 接入方式：\n\n1. **Core ACP Gateway**：Core 面向上游作为 ACP Agent（接受多个 Client 连接），面向下游作为 ACP Client（持有唯一 AcpConnection 到 Agent 子进程），Session 多路复用。\n2. **Proxy 薄层化**：Proxy 退化为纯 transport 转换层（stdio ↔ Unix socket），不理解 ACP 消息内容。\n3. **agent chat 作为 ACP Client**：内置简易 ACP Client，通过 Core ACP Gateway 接入，获得流式输出、取消、实时通知等完整 ACP 能力。\n4. **多 Client 天然支持**：Core 做 Session 多路复用，IDE + Chat 可同时连接同一 Agent。\n\n本 Issue 的 Gateway 架构同时为后续场景奠定基础：\n- **场景 8: Web UI** — HTTP REST + WebSocket 接入 Core ACP Gateway\n- **场景 9: Docker + IM** — HTTP Webhook + IM Adapter 接入 Core ACP Gateway\n\n> 完整 9 种场景分析参见 [Agent 启动场景与 ACP 架构](docs/design/agent-launch-scenarios.md)\n\n### 核心架构原则\n\n**ACP Gateway 极简化**：Gateway 只做 session 路由，不解析/修改 ACP 消息内容。仅维护 `sessionId → upstream Client` 映射表。\n\n**ACP Client 并行结构**：所有 ACP Client（外部 IDE via Proxy、agent chat 内置、Web UI、IM Adapter）是并行 peers，地位平等，独立连接 Gateway，互不依赖。\n\n```\n  IDE (外部ACP Client via Proxy) ──ACP/socket──┐\n  Desktop (外部ACP Client via Proxy) ──ACP/socket──┤\n  agent chat (内置ACP Client) ──ACP/socket──┤      ← 并行 peers\n  Web UI (WebSocket ACP Client) ───────────┤      (future)\n  IM Adapter (HTTP ACP Client) ────────────┤      (future)\n                                            ▼\n                 ACP Gateway (极简 session 路由器)\n                 ├─ sessionId → Client 映射\n                 ├─ 上行: 转发到 Agent\n                 └─ 下行: 按 sessionId 路由回 Client\n                                            │\n                                       ACP / stdio\n                                            │\n                                      Agent 子进程\n```\n\n**协议分工**：RPC 层处理管理操作，ACP Gateway 层只做 session 路由。Gateway 不含业务逻辑。\n\n## 背景\n\n### Proxy 的问题\n\n当前 ACP Proxy (#16) 已实现基本的消息转发，但存在关键不足：\n\n1. **握手是硬编码的**：Proxy 返回固定的 `initialize` 响应，未反映真实 Agent 的能力声明\n2. **仅支持 `session/prompt` 和 `session/cancel`**：缺失 `session/new`、`session/load`、`setSessionMode` 等完整会话管理\n3. **工具授权未转发**：Agent 的 `requestPermission` 请求在 Daemon 侧被 auto-approve 或 deny，外部客户端完全无感知\n4. **工具调用不透明**：Agent 执行的 tool_call / tool_call_update 事件未实时回传到外部客户端\n5. **无流式响应**：当前 `proxy.forward` 等待完整响应后一次返回，外部客户端看不到中间过程\n6. **环境请求穿透未实现**：`--env-passthrough` 模式设计了但 `readTextFile`/`writeTextFile`/`terminal` 等请求未真正穿透回外部客户端\n7. **反向通道缺失**：Daemon→Proxy 方向无推送能力，导致 Agent 回调无法实时回传\n\n### agent chat 的问题\n\n当前 `agent chat` 经过 RPC → Daemon → ACP Connection 的中继路径，存在根本性限制：\n\n1. **非流式**：RPC 层是 Unix socket JSON-RPC request/response，每次等完整回复后才输出，长回复需干等\n2. **不能取消**：回复过程中无法 Ctrl+C 取消当前 prompt\n3. **ACP 通知被吞**：sessionUpdate 中的 tool_call、agent_message_chunk 等实时通知全部在 daemon 内部消化，CLI 端完全无感\n4. **单 session 限制**：只使用 daemon 的 primary session，无法创建或管理多个 session\n5. **本质问题**：把 ACP 的实时交互塞进 RPC request/response，是在 ACP 协议外面套了一层低能力的传输协议\n\n## 方案演进\n\n### 弃用方案 1：增强 proxy.forward（Daemon RPC 中继）\n\n需要改造 SocketServer 支持双向推送，ACP→RPC→ACP 双协议翻译，复杂且易出错。\n\n### 弃用方案 2：Proxy Direct Bridge（Proxy 直连 Agent）\n\nProxy 自己 spawn Agent 子进程并持有 AcpConnection。问题：多 Client 需要互斥，Daemon 被架空看不到实时状态，每个 Client 各管各的生命周期。\n\n### 采用方案：Core ACP Gateway（极简 session 路由器）\n\n核心思路：**Gateway 只做一件事——按 sessionId 转发消息**。所有 ACP Client 并行连接 Gateway，地位平等。\n\n```\n  IDE (外部ACP Client) ──Proxy──┐\n  Desktop (外部ACP Client) ──Proxy──┤\n  agent chat (内置ACP Client) ──────┤  ← 并行 peers，互不依赖\n                                     ▼\n              ACP Gateway (session 路由器)\n              ├─ sessionId → Client 映射\n              ├─ 上行: msg → Agent\n              └─ 下行: notification → 按 sessionId 路由\n                                     │\n                                ACP / stdio\n                                     │\n                               Agent 子进程\n```\n\n关键设计约束：\n- **Gateway 极简**：只维护 sessionId→Client 映射，不解析/修改/拦截 ACP 消息\n- **Client 并行**：Proxy(IDE)、Chat、Web UI、IM Adapter 都是独立 ACP Client，互不依赖\n- **Proxy 是 Client 的 transport**：不是 Gateway 的一部分，只做 stdio↔socket 转换\n- **Chat 与 Proxy 同级**：内置 ACP Client 和外部 ACP Client 地位完全平等\n\n### 优势对比\n\n| 维度 | RPC 中继 (当前) | Proxy Direct Bridge (弃用) | Core ACP Gateway (采用) |\n|------|----------------|---------------------------|------------------------|\n| 流式输出 | 不支持 | 支持 | 支持 |\n| 多 Client | 不支持 | 互斥 | **天然支持** |\n| Core 可观测性 | 部分 | 低 | **完全** |\n| ACP 能力 | 受限 | 完整 | 完整 |\n| 协议翻译 | ACP→RPC→ACP | 无 | 无 |\n| Daemon 角色 | 持有 ACP + RPC 中转 | 仅 resolve/attach/detach | **持有 ACP + Gateway** |\n\n## 数据流设计\n\n### Client → Agent 方向（Agent 接口方法全部透传）\n\n```\nIDE --[initialize]--> AgentSideConnection --> Bridge --> ClientSideConnection --[initialize]--> Agent\nIDE --[session/new]--> AgentSideConnection --> Bridge --> ClientSideConnection --[session/new]--> Agent\nIDE --[session/prompt]--> ... --> Agent\nIDE --[session/cancel]--> ... --> Agent\nIDE --[session/load]--> ... --> Agent\nIDE --[setSessionMode]--> ... --> Agent\nIDE --[setSessionConfigOption]--> ... --> Agent\nIDE --[authenticate]--> ... --> Agent\n// unstable 方法同样透传\nIDE --[forkSession]--> ... --> Agent\nIDE --[resumeSession]--> ... --> Agent\nIDE --[listSessions]--> ... --> Agent\nIDE --[setSessionModel]--> ... --> Agent\n```\n\n### Agent → Client 方向（根据模式处理）\n\n**Workspace 隔离模式（默认）**:\n```\nAgent --[sessionUpdate]--> CSC --> Bridge --> ASC --[sessionUpdate]--> IDE    (始终转发)\nAgent --[requestPermission]--> CSC --> Bridge --> 自动批准                    (本地处理)\nAgent --[readTextFile]--> CSC --> Bridge --> 本地文件系统 (workspace 内)       (本地处理)\nAgent --[writeTextFile]--> CSC --> Bridge --> 本地文件系统 (workspace 内)      (本地处理)\nAgent --[createTerminal]--> CSC --> Bridge --> 本地终端                       (本地处理)\n```\n\n**Env 穿透模式（--env-passthrough）**:\n```\nAgent --[sessionUpdate]--> CSC --> Bridge --> ASC --[sessionUpdate]--> IDE    (始终转发)\nAgent --[requestPermission]--> CSC --> Bridge --> ASC --[requestPermission]--> IDE  (穿透)\nAgent --[readTextFile]--> CSC --> Bridge --> ASC --[readTextFile]--> IDE      (穿透到 IDE 端文件系统)\nAgent --[writeTextFile]--> CSC --> Bridge --> ASC --[writeTextFile]--> IDE    (穿透)\nAgent --[createTerminal]--> CSC --> Bridge --> ASC --[createTerminal]--> IDE  (穿透到 IDE 端终端)\n```\n\n## 实现计划\n\n### Phase 1: ACP Gateway（极简 session 路由器）\n\nGateway 只做 session 路由，不含业务逻辑：\n\n1. **`packages/acp/src/gateway.ts`**（新增）— 极简 session 路由器：\n   - 维护 `sessionId → upstream Client connection` 映射表\n   - 上行：接收 Client 消息，提取 sessionId，转发到下游 AcpConnection\n   - 下行：接收 Agent 通知，提取 sessionId，路由回对应的 Client\n   - 不解析/修改/拦截消息内容\n\n2. **`packages/api/src/daemon/acp-socket-server.ts`**（新增）— ACP Unix socket 服务端：\n   - 接受多个并行 Client 连接（ndjson stream）\n   - 每个连接注册到 Gateway 的映射表\n\n3. **`packages/api/src/daemon/daemon.ts`**（修改）— Daemon 新增 ACP socket：\n   - RPC socket（管理操作，已有）\n   - ACP socket（实时交互，新增）\n\n### Phase 2: Proxy 薄层化\n\n**重写 `packages/cli/src/commands/proxy.ts`**\n\nProxy 退化为纯 transport 转换（stdio ↔ Unix socket）：\n1. 确认 agent 已运行（`agent.status`）\n2. 连接 Core 的 ACP socket\n3. stdin → ACP socket，ACP socket → stdout（透明转发）\n4. 退出时断开\n\nProxy 不再 spawn Agent 子进程、不持有 AcpConnection、不做 attach/detach。\n\n### Phase 3: agent chat 作为 ACP Client\n\n**重写 `packages/cli/src/commands/agent/chat.ts`**\n\nagent chat 内置简易 ACP Client，通过 Core ACP Gateway 接入：\n1. 确认 agent 已运行（`agent.status`），未运行则自动 `agent.start`\n2. 连接 Core 的 ACP socket，作为 ACP Client\n3. readline 循环：\n   - 用户输入 → `session/prompt` 发送\n   - 接收 `sessionUpdate` 通知 → 逐 chunk 流式渲染\n   - Ctrl+C → `session/cancel` 取消当前 prompt\n4. 退出时断开\n\n**新增 `packages/cli/src/output/stream-renderer.ts`**\n\n终端流式渲染器，消费 `sessionUpdate` 通知并输出到终端：\n- `agent_message_chunk` (text) → 逐字输出（打字机效果）\n- `tool_call` / `tool_call_update` → `[tool: name]` 格式化展示\n- 与 readline prompt 协调\n\n### Phase 4: 更新导出和文档\n\n- **`packages/acp/src/index.ts`**: 新增导出 Gateway 相关类型\n- **`packages/api/src/handlers/proxy-handlers.ts`**: 标注 legacy，新 proxy 不再使用\n- **`.trellis/spec/api-contracts.md`**: ✅ 已更新 section 7\n- **`docs/design/agent-launch-scenarios.md`**: ✅ 已创建\n- 现有 RPC `agent.run` / `agent.prompt` 保留给管理/脚本场景\n\n## 边界情况处理\n\n- **Agent 已通过 `agent.start` 运行**: Proxy 报错 \"Agent is already running. Stop it first with `agentcraft agent stop <name>`\"\n- **Agent 不存在**: 使用 `-t/--template` 选项自动创建（`agent.resolve` 支持 template 参数）\n- **Agent 进程意外退出**: Bridge 检测到 ClientSideConnection 关闭 → 通知外部客户端 → Proxy 退出\n- **外部客户端断开**: Bridge 检测到 AgentSideConnection 关闭 → 终止 Agent 进程 → 清理\n- **SIGINT/SIGTERM**: Proxy 优雅关闭 → 终止 Agent → detach → 退出\n- **多 Proxy 同一 Agent**: `agent.attach` 会检测冲突，第二个 proxy 报 AGENT_ALREADY_ATTACHED 错误\n\n## 依赖\n\n- `@agentclientprotocol/sdk` v0.14.1 — 需使用 `AgentSideConnection` 和 `ClientSideConnection`\n- #16 ACP Proxy 基础（✅ 已完成）\n- #12 Daemon ↔ Agent 通信（✅ 已完成）\n- 已有 `agent.resolve` / `agent.attach` / `agent.detach` RPC 方法（✅ 已实现）\n\n## 需要修改的文件\n\n| 文件 | 变更 |\n|------|------|\n| `packages/acp/src/gateway.ts` | **新增** — ACP Gateway 核心类（AgentSideConnection + Session 多路复用） |\n| `packages/api/src/daemon/acp-socket-server.ts` | **新增** — ACP over Unix socket 服务端 |\n| `packages/api/src/daemon/daemon.ts` | **修改** — 启动时同时启动 ACP socket |\n| `packages/acp/src/index.ts` | 新增导出 Gateway 相关类型 |\n| `packages/cli/src/commands/proxy.ts` | **重写** — 纯 stdio↔socket transport 层 |\n| `packages/cli/src/commands/agent/chat.ts` | **重写** — 内置 ACP Client 连 Core Gateway |\n| `packages/cli/src/output/stream-renderer.ts` | **新增** — 终端流式渲染器 |\n| `packages/api/src/handlers/proxy-handlers.ts` | 保留 legacy，标注废弃 |\n| `.trellis/spec/api-contracts.md` | ✅ 已更新 section 7 架构描述 |\n| `docs/design/agent-launch-scenarios.md` | ✅ 已创建 — 7 种场景完整文档 |\n| `packages/acp/src/__tests__/gateway.test.ts` | **新增** — Gateway 单元测试 |\n\n## 验收标准\n\n### Proxy\n- [ ] 外部 ACP Client 通过 `agentcraft proxy <name>` 连接，收到真实 Agent 能力声明（非硬编码）\n- [ ] 可通过 Proxy 完成 `initialize` → `session/new` → `session/prompt` → `session/cancel` 全流程\n- [ ] Agent 的 `session/update` 通知实时流式转发到外部客户端\n- [ ] Agent 的 `requestPermission` 在 env-passthrough 模式下穿透到外部客户端\n- [ ] Agent 的 `readTextFile`/`writeTextFile` 在 workspace-isolation 模式下本地处理，env-passthrough 模式下穿透\n- [ ] `session/load`、`setSessionMode` 等完整 ACP 生命周期方法均可通过 Proxy 使用\n- [ ] Proxy 退出时 Agent 进程优雅终止，Daemon 中状态正确清理\n- [ ] 单元测试覆盖 AcpBridge 核心转发逻辑和双模式切换\n- [ ] 与 Claude Desktop / Cursor 等标准 ACP Client 联调通过\n\n### agent chat\n- [ ] `agent chat <name>` 直接作为 ACP Client 连接 agent，不经过 RPC agent.run 中转\n- [ ] 流式输出：agent 回复逐 chunk 实时渲染到终端（打字机效果）\n- [ ] 取消支持：Ctrl+C 触发 conn.cancel(sessionId)，中断当前 prompt\n- [ ] 实时通知：tool_call 等 sessionUpdate 事件在终端展示（如 `[tool: name]`）\n- [ ] 生命周期正确：spawn → attach → 交互 → close → detach，Daemon 状态一致\n- [ ] 向后兼容：RPC `agent.run` / `agent.prompt` 保留给脚本/管理场景",
  "author": "cursor-agent",
  "assignees": [],
  "relatedFiles": [
    "packages/acp/src/gateway.ts",
    "packages/acp/src/connection.ts",
    "packages/acp/src/index.ts",
    "packages/api/src/daemon/acp-socket-server.ts",
    "packages/api/src/daemon/daemon.ts",
    "packages/cli/src/commands/proxy.ts",
    "packages/cli/src/commands/agent/chat.ts",
    "packages/cli/src/output/stream-renderer.ts",
    "packages/api/src/handlers/proxy-handlers.ts",
    ".trellis/spec/api-contracts.md",
    "docs/design/agent-launch-scenarios.md"
  ],
  "relatedIssues": [16, 12],
  "taskRef": null,
  "githubRef": null,
  "closedAs": null,
  "comments": [
    {
      "text": "方案更新：从增强 proxy.forward（Daemon 中继）改为 Proxy Direct Bridge（双连接桥接）。Proxy 进程直接持有 AgentSideConnection + ClientSideConnection，透明桥接所有 ACP 方法，Daemon 仅做 resolve/attach/detach 生命周期管理。详细设计见 body 更新。",
      "date": "2026-02-21T02:30:00",
      "author": "cursor-agent"
    },
    {
      "text": "范围扩展：将 agent chat 直连 ACP Client 纳入本 Issue。",
      "date": "2026-02-21T03:00:00",
      "author": "human"
    },
    {
      "text": "架构重设计：从 Proxy Direct Bridge 演进为 Core ACP Gateway。Core 持有 AcpConnection，Session 多路复用。已创建 docs/design/agent-launch-scenarios.md（9 种场景），已更新 api-contracts.md Section 7 和 spec/index.md。",
      "date": "2026-02-21T03:30:00",
      "author": "human"
    },
    {
      "text": "架构修正：(1) ACP Gateway 极简化——只做 sessionId 路由转发，不解析/修改/拦截 ACP 消息内容，不含业务逻辑。(2) 所有 ACP Client（外部 IDE via Proxy、agent chat 内置、Web UI、IM Adapter）是并行 peers，地位平等，独立连接 Gateway，互不依赖。Proxy 不是 Gateway 的一部分，是外部 Client 的 transport 层。Chat 与 Proxy 同级。",
      "date": "2026-02-21T04:00:00",
      "author": "human"
    }
  ],
  "createdAt": "2026-02-20T18:30:00",
  "updatedAt": "2026-02-21T04:00:00",
  "closedAt": null
}
